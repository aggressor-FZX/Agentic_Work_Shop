# Agentic Work Shop

- This was built on WSL Ubuntu for linux. 
- Refuse to develop on anything else.

***

# Scaling Your Setup: A Concrete Example

This document walks through a simple, concrete example of giving an orchestrator a goal (like ‚Äúbuild a project‚Äù) inside a subdirectory of your current repository.

## üß© Scenario

You are in the following directory:

```bash
~/cpts_483/Agentic_Work_Shop/
```

And you have a subproject with this structure:

```
Agentic_Work_Shop/
‚îî‚îÄ‚îÄ projects/
    ‚îî‚îÄ‚îÄ verilog_adder/
        ‚îú‚îÄ‚îÄ src/
        ‚îú‚îÄ‚îÄ tests/
        ‚îî‚îÄ‚îÄ README.md
```

Your goal is to have the AI worker: **‚ÄúBuild and test everything inside `projects/verilog_adder`‚Äù** while leaving the main `Agentic_Work_Shop` folder untouched.

---

### üß± Step 1: Start Infrastructure
If you don't have it, do a manual install of Compose V2 in WSL
From the `Agentic_Work_Shop` root directory, run the following command to start the necessary services:

```bash
docker compose up -d --build
```

‚úÖ This command starts:

*   **RabbitMQ** (the job queue)
*   **Redis** (the memory store)
*   **Worker** (the AI agent executor)

---

### üß† Step 2: Create a Simple Goal

Next, let's tell the AI to build the subproject in the specified folder.

First, activate your Python virtual environment:

```bash
source .venv/bin/activate
```

Now, run the `enqueue.py` script with your goal:

```bash
python enqueue.py \
  "Build and test the Verilog adder project" \
  projects/verilog_adder/src projects/verilog_adder/tests \
  --iters 3
```

#### üß© What Happens Next

1.  `enqueue.py` packages your goal, scope, and iteration count into a job.
2.  That job is sent to **RabbitMQ**.
3.  Your **Celery worker** pulls the job and calls the following function:

    ```python
    run_manager("Build and test the Verilog adder project",
                ["projects/verilog_adder/src", "projects/verilog_adder/tests"],
                max_iter=3)
    ```

Inside `manager.py` (or `Orchistrate.py`):

*   The **Planner** decides what actions to take.
*   The **Coder** writes or modifies files, but *only* in `projects/verilog_adder/src`.
*   Environment and testing tools (like `pytest`, `make`, etc.) run inside that specific folder.
*   The **Reviewer** validates the changes and finalizes the process.

Everything remains scoped to the `verilog_adder` subdirectory because the orchestrator‚Äôs `target_paths` limit all file edits to those specified paths.

---

### üßæ Step 3: Watch It Work

To see the live logs from the worker, run:

```bash
docker compose logs -f worker
```

You can also check the job status in RabbitMQ‚Äôs web UI, which is available at:

[http://localhost:15672](http://localhost:15672) (user: `agent`, pass: `agentpass`)

If you are writing logs to a file (e.g., `manager.log`), you can follow the log output with:

```bash
tail -f manager.log
```

---

### üß™ Step 4: Verify the Results

Once the process is complete, you will have:

*   Modified files under `projects/verilog_adder/src` and `tests`.
*   A result object returned by `run_manager()` (which Celery also stores in Redis).

You can optionally run the tests manually to confirm the results:

```bash
pytest projects/verilog_adder/tests
```

---

## üîÑ Development Loop Overview

The Agentic Work Shop uses a structured development loop powered by LangGraph to autonomously implement and test code changes. The loop consists of five main stages that iterate until completion:

### **Loop Stages:**

1. **Plan** ‚Üí AI analyzes the goal and creates a high-level implementation plan
2. **Code** ‚Üí AI generates code changes as unified diffs targeting only specified paths
3. **Environment** ‚Üí AI requests necessary tools/dependencies for the task
4. **Test** ‚Üí Code changes are applied and tests are run; auto-install missing dependencies if needed
5. **Review** ‚Üí AI evaluates test results and decides to iterate or finalize

### **Iteration Logic:**
- Maximum 3 iterations allowed
- Loop continues if tests fail AND reviewer requests iteration
- Loop terminates on test pass + reviewer finalization OR max iterations reached

### **Safety Features:**
- File modifications limited to specified `target_paths`
- Tool execution restricted to allowlist
- Git-based patching with rollback capability
- Comprehensive logging to `manager.log`

---

## ü§ñ Default Agent Prompts

Each agent in the LangGraph workflow uses carefully crafted prompts to ensure focused, safe, and effective AI behavior:

### **Planner Agent**
```
Plan steps to achieve:
Goal: {state['goal']}
Scope: {state['target_paths']}
```

### **Environment Agent**
```
You can request tools strictly using 'TOOL: <name> <args>'.
Allowed tools: pip_install, npm_install, pytest, ruff, black_check, flake8, mypy, cmake_build, ctest.
Goal: {state['goal']}
Repo paths: {state['target_paths']}

Output only TOOL: lines for dependencies to install or basic setup steps.
If none needed, output nothing.
Examples:
TOOL: pip_install pytest ruff
TOOL: npm_install jest
```

### **Coder Agent**
```
Goal: {state['goal']}
Plan:
{state['plan']}
Touch only {state['target_paths']}
Return a single unified diff, no prose.
```

### **Reviewer Agent**
```
Tests: {state['test_result']}
Logs (tail): {state['test_log'][:2000]}

If FAIL:
- Provide one-sentence reason,
- then (optionally) lines starting with 'TOOL:' to install deps or run a specific allowed tool,
- then finish with either:
  ACTION:ITERATE <one-line next change>
If PASS:
  ACTION:FINALIZE

Allowed tools: pip_install, npm_install, pytest, ruff, black_check, flake8, mypy, cmake_build, ctest.
```

### **Key Prompt Design Principles:**
- **Constrained Output**: Agents produce structured, parseable responses
- **Safety First**: Tool requests use explicit `TOOL:` syntax
- **Scoped Actions**: File modifications limited to `target_paths`
- **Iterative Refinement**: Review-based feedback loop
- **Minimal Prose**: Focus on actionable outputs over explanations

---

## üîç Context7 Integration

The Agentic Work Shop integrates **Context7 MCP** for up-to-date library and toolkit documentation. Context7 provides live, version-aware documentation that helps agents stay current with rapidly evolving libraries.

### **When Agents Use Context7**

Agents automatically use Context7 when they encounter:
- Unfamiliar libraries or toolkits
- Libraries that may have changed in the past 12 months
- Need for specific API examples or breaking changes

### **Context7 Workflow**

1. **Detection**: Planner/Research agents identify knowledge gaps
2. **Query**: Use `TOOL: context7_docs "<query>"` for documentation
3. **Storage**: Results stored in unified memory for reuse
4. **Integration**: Future agents read from memory for accurate code generation

### **Example Usage**

```
TOOL: context7_docs "React Query v5 invalidate API"
TOOL: mem_put docs/react-query-v5 {"text":"...", "source":"context7"}
TOOL: mem_get docs/react-query-v5  # Later retrieval
```

### **Installation**

Context7 is included in the project dependencies. For local MCP server usage:

```bash
npm install
npx -y @upstash/context7-mcp --api-key YOUR_KEY
```

### **Benefits**

- **Current Knowledge**: Access to latest library versions and APIs
- **Memory Integration**: Documentation stored alongside project knowledge
- **Fallback Safety**: Works alongside web search and paper search tools
- **Version Awareness**: Handles breaking changes and deprecations